<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AnkiGenius - Smart Flashcard Generator</title>
    
    <!-- Google Fonts: Inter for a clean, professional look --><link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Tailwind CSS for modern styling --><script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Tesseract.js for Image Occlusion OCR --><script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    
    <!-- JSZip & FileSaver.js for .apkg file creation --><script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/sql-asm.js"></script>
    <!-- genanki-js for Anki deck generation (FIXED: Using the correct build) --><script src="https://cdn.jsdelivr.net/npm/genanki-js/dist/genanki.js"></script>
    
    <!-- PDF.js for PDF parsing --><script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <script>pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';</script>
    
    <!-- Mammoth.js for DOCX parsing --><script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>

    <!-- Theme and CSS styling --><script>
        // Apply dark mode immediately if system prefers or it's saved
        if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.classList.add('dark');
        } else {
            document.documentElement.classList.remove('dark');
        }
    </script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        
        /* Base styles for a clean, professional look inspired by RemNote/Anki */
        .bg-page {
            @apply bg-gray-50 dark:bg-gray-900 text-gray-900 dark:text-gray-100 transition-colors duration-300;
        }
        .container-base {
            @apply max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8;
        }

        /* Card and Modal Styling (subtle glassmorphism) */
        .panel {
            @apply relative p-6 bg-white dark:bg-gray-800 rounded-2xl shadow-lg border border-gray-200 dark:border-gray-700 backdrop-filter backdrop-blur-md bg-opacity-80 dark:bg-opacity-80 transition-all duration-300;
        }
        .modal-backdrop {
            @apply fixed inset-0 bg-gray-900/60 dark:bg-black/70 backdrop-blur-sm flex items-center justify-center z-50 transition-opacity duration-300;
        }
        .modal-content {
            @apply bg-white dark:bg-gray-800 rounded-xl p-8 shadow-2xl w-full max-w-md transition-colors duration-300;
        }

        /* Form Elements */
        .form-label {
            @apply block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1;
        }
        .form-input {
            @apply mt-1 block w-full px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg shadow-sm bg-gray-50 dark:bg-gray-700 text-gray-800 dark:text-gray-100 placeholder-gray-400 dark:placeholder-gray-500 focus:ring-indigo-500 focus:border-indigo-500 transition-colors duration-200;
        }
        .form-textarea {
            @apply resize-y; /* Allow vertical resizing */
        }
        .file-input-button {
            @apply flex items-center justify-center px-4 py-2 text-sm font-medium text-indigo-700 dark:text-indigo-200 bg-indigo-50 dark:bg-indigo-900 hover:bg-indigo-100 dark:hover:bg-indigo-800 rounded-lg border border-indigo-200 dark:border-indigo-700 cursor-pointer transition-colors duration-200;
        }

        /* Buttons */
        .btn-primary {
            @apply w-full bg-indigo-600 text-white font-semibold py-3 px-4 rounded-xl hover:bg-indigo-700 dark:bg-indigo-500 dark:hover:bg-indigo-600 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800 transition-all duration-200;
        }
        .btn-green {
            @apply w-full bg-green-600 text-white font-semibold py-3 px-4 rounded-xl hover:bg-green-700 dark:bg-green-500 dark:hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800 transition-all duration-200;
        }
        .btn-secondary {
            @apply px-4 py-2 text-sm font-medium text-gray-700 dark:text-gray-300 bg-gray-100 dark:bg-gray-700 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors duration-200;
        }
        .btn-icon {
            @apply p-2 rounded-full text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors duration-200;
        }

        /* Navigation */
        .nav-link {
            @apply px-4 py-2 text-lg font-medium text-gray-600 dark:text-gray-400 hover:text-indigo-600 dark:hover:text-indigo-400 border-b-4 border-transparent hover:border-indigo-500 dark:hover:border-indigo-400 transition-all duration-200;
        }
        .nav-link.active {
            @apply text-indigo-700 dark:text-indigo-500 border-indigo-600 dark:border-indigo-500;
        }

        /* Page Display Control */
        .page { display: none; }
        .page.active { display: block; }

        /* Image Occlusion Specific Styles */
        #io-image-wrapper {
            position: relative;
            width: 100%;
            height: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 1rem; /* Match panel radius */
            overflow: hidden;
            background-color: transparent; /* Ensure transparent background */
            user-select: none; /* Prevent image dragging/selection */
        }
        #io-display-image {
            display: block;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        #io-canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            background-color: transparent; /* Ensure canvas itself is transparent */
        }
        #io-occlusion-list {
            @apply h-48 overflow-y-auto border border-gray-200 dark:border-gray-700 rounded-lg bg-gray-50 dark:bg-gray-700 p-2;
        }
        .occlusion-item {
            @apply flex items-center justify-between p-2 mb-1 bg-indigo-50 dark:bg-indigo-900 rounded-md text-sm text-gray-800 dark:text-gray-100;
        }
        .occlusion-remove-btn {
            @apply text-red-500 dark:text-red-400 hover:text-red-700 dark:hover:text-red-300 font-bold ml-2;
        }

        /* Custom scrollbar for dark mode */
        .dark ::-webkit-scrollbar {
            width: 8px;
        }
        .dark ::-webkit-scrollbar-track {
            background: #374151; /* gray-700 */
            border-radius: 10px;
        }
        .dark ::-webkit-scrollbar-thumb {
            background: #4b5563; /* gray-600 */
            border-radius: 10px;
        }
        .dark ::-webkit-scrollbar-thumb:hover {
            background: #6b7280; /* gray-500 */
        }
    </style>
</head>
<body class="bg-page min-h-screen">

    <!-- === SETTINGS MODAL === --><div id="settings-modal" class="modal-backdrop hidden">
        <div class="modal-content">
            <h2 class="text-2xl font-bold mb-4 text-indigo-700 dark:text-indigo-400">AnkiGenius Settings</h2>
            <p class="mb-5 text-gray-600 dark:text-gray-400">
                Enter your Google AI (Gemini) API key. It's stored locally in your browser and never leaves your device.
            </p>
            
            <label for="api-key" class="form-label">Google AI (Gemini) API Key</label>
            <input type="password" id="api-key" class="form-input" placeholder="Paste your Gemini API key here...">
            <p class="text-xs text-gray-500 dark:text-gray-400 mt-1 mb-6">
                Get a free key from <a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-indigo-600 dark:text-indigo-400 hover:underline">Google AI Studio</a>.
            </p>
            
            <button id="save-settings" class="btn-primary">Save Settings</button>
        </div>
    </div>
    
    <!-- === LOADING MODAL === --><div id="loading-modal" class="modal-backdrop hidden">
        <div class="modal-content flex flex-col items-center justify-center p-6 text-center max-w-sm">
            <svg class="animate-spin h-10 w-10 text-indigo-600 dark:text-indigo-400 mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
            <h3 id="loading-status" class="text-xl font-medium text-gray-800 dark:text-gray-100">Please wait...</h3>
        </div>
    </div>
    
    <!-- === HEADER & NAVIGATION === --><header class="sticky top-0 z-40 bg-white dark:bg-gray-800 bg-opacity-70 dark:bg-opacity-70 backdrop-filter backdrop-blur-md shadow-sm">
        <nav class="container-base flex items-center justify-between py-3">
            <h1 class="text-3xl font-bold text-indigo-700 dark:text-indigo-400">AnkiGenius</h1>
            <div class="flex-grow flex justify-center space-x-2 md:space-x-6">
                <button class="nav-link active" data-page="page-create">Create Flashcards</button>
                <button class="nav-link" data-page="page-image-occlusion">Image Occlusion</button>
            </div>
            <button id="settings-button" class="btn-icon">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826 3.31 2.37-2.37.996.608 2.296.096 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
            </button>
        </nav>
    </header>

    <!-- === MAIN CONTENT === --><main class="container-base">

        <!-- === PAGE: CREATE FLASHCARDS === --><div id="page-create" class="page active">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                
                <!-- Topic Generator --><div class="panel">
                    <h2 class="text-2xl font-bold mb-5 text-indigo-700 dark:text-indigo-400">Generate from Topic</h2>
                    <div class="space-y-4">
                        <div>
                            <label for="topic" class="form-label">Topic or Subject</label>
                            <input type="text" id="topic" class="form-input" placeholder="e.g., 'World War II causes'">
                        </div>
                        <div>
                            <label for="topic-deck-name" class="form-label">Anki Deck Name</label>
                            <input type="text" id="topic-deck-name" class="form-input" placeholder="e.g., 'History: WWII Causes'">
                        </div>
                        <div>
                            <label for="topic-num-cards" class="form-label">Number of Cards</label>
                            <input type="number" id="topic-num-cards" value="10" min="1" class="form-input">
                        </div>
                        <button id="generate-topic" class="btn-primary mt-4">Generate Deck</button>
                    </div>
                </div>

                <!-- Text Generator --><div class="panel">
                    <h2 class="text-2xl font-bold mb-5 text-indigo-700 dark:text-indigo-400">Generate from Text</h2>
                    <div class="space-y-4">
                        <div>
                            <label for="text-input" class="form-label">Paste your study notes or article</label>
                            <textarea id="text-input" rows="8" class="form-input form-textarea" placeholder="Paste your study notes here..."></textarea>
                        </div>
                        <div>
                            <label for="text-deck-name" class="form-label">Anki Deck Name</label>
                            <input type="text" id="text-deck-name" class="form-input" placeholder="e.g., 'My Biology Notes'">
                        </div>
                        <div>
                            <label for="text-num-cards" class="form-label">Number of Cards</label>
                            <input type="number" id="text-num-cards" value="20" min="1" class="form-input">
                        </div>
                        <button id="generate-text" class="btn-primary mt-4">Generate Deck</button>
                    </div>
                </div>
                
                <!-- File Generator --><div class="panel md:col-span-2">
                    <h2 class="text-2xl font-bold mb-5 text-indigo-700 dark:text-indigo-400">Generate from File (PDF or DOCX)</h2>
                    <div class="space-y-4">
                        <div>
                            <label class="form-label">Upload your .pdf or .docx document</label>
                            <label for="file-upload" class="file-input-button">
                                <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
                                <span id="file-upload-label">Choose File</span>
                                <input id="file-upload" type="file" accept=".pdf,.docx" class="hidden"/>
                            </label>
                            <p id="file-name-display" class="text-sm text-gray-500 dark:text-gray-400 mt-2">No file selected.</p>
                        </div>
                        <div>
                            <label for="file-deck-name" class="form-label">Anki Deck Name</label>
                            <input type="text" id="file-deck-name" class="form-input" placeholder="e.g., 'Chapter 5 Study Guide'">
                        </div>
                        <div>
                            <label for="file-num-cards" class="form-label">Number of Cards</label>
                            <input type="number" id="file-num-cards" value="20" min="1" class="form-input">
                        </div>
                        <button id="generate-file" class="btn-primary mt-4">Generate Deck</button>
                    </div>
                </div>
            </div>
            
            <!-- Log Output --><div class="panel mt-8">
                <label class="form-label">Generation Log</label>
                <textarea id="log-output" rows="10" class="w-full p-4 bg-gray-900/90 dark:bg-black/80 text-green-400 font-mono text-sm rounded-lg border border-gray-700 dark:border-gray-600 transition-colors duration-200" readonly>Waiting for task...</textarea>
            </div>
        </div>

        <!-- === PAGE: IMAGE OCCLUSION === --><div id="page-image-occlusion" class="page">
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
                <!-- Image Occlusion Controls --><div class="lg:col-span-1 panel h-fit">
                    <h2 class="text-2xl font-bold mb-5 text-indigo-700 dark:text-indigo-400">Image Occlusion Tool</h2>
                    <p class="text-gray-600 dark:text-gray-400 mb-6">
                        Upload an image, then use "Scan Image" for auto-detection or "Manual Mode" to draw boxes. Click selected boxes to mark for occlusion.
                    </p>

                    <div class="mb-6">
                        <label class="form-label">1. Upload Image</label>
                        <label for="io-image-upload" class="file-input-button">
                            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
                            <span id="io-file-upload-label">Choose Image</span>
                            <input id="io-image-upload" type="file" accept="image/*" class="hidden"/>
                        </label>
                        <p id="io-file-name-display" class="text-sm text-gray-500 dark:text-gray-400 mt-2">No image selected.</p>
                    </div>
                    
                    <div class="mb-4">
                        <label class="form-label">2. Detect Text</label>
                        <button id="io-scan-button" disabled class="btn-primary py-2 disabled:opacity-50 disabled:bg-gray-500">Scan Image for Text</button>
                    </div>
                    
                    <div class="flex items-center justify-between p-3 bg-gray-100 dark:bg-gray-700 rounded-lg mb-6">
                        <label for="io-manual-toggle" class="form-label mb-0">Manual Selection Mode</label>
                        <input type="checkbox" id="io-manual-toggle" class="h-5 w-5 text-indigo-600 dark:text-indigo-400 rounded focus:ring-indigo-500">
                    </div>
                    
                    <div class="mb-6">
                        <label class="form-label">3. Selected Occlusions</label>
                        <div id="io-occlusion-list">
                            <p id="io-placeholder" class="text-center text-gray-500 dark:text-gray-400 p-4">Click detected text or draw a box to add an occlusion.</p>
                        </div>
                    </div>
                    
                    <div class="border-t border-gray-200 dark:border-gray-700 pt-6">
                        <label for="io-deck-name" class="form-label">4. Anki Deck Name</label>
                        <input type="text" id="io-deck-name" value="Image Occlusion Deck" class="form-input mb-4">
                        <button id="io-export-button" disabled class="btn-green disabled:opacity-50 disabled:bg-gray-500">Generate .apkg File</button>
                    </div>
                </div>

                <!-- Image Occlusion Display --><div class="lg:col-span-2 panel flex items-center justify-center min-h-[500px] lg:min-h-[600px] overflow-hidden">
                    <div id="io-image-wrapper" class="hidden">
                        <img id="io-display-image" src="" alt="Uploaded image for occlusion"/>
                        <canvas id="io-canvas"></canvas>
                    </div>
                    <div id="io-upload-placeholder" class="text-center text-gray-500 dark:text-gray-400 p-8">
                        <svg class="mx-auto h-24 w-24 text-gray-400" stroke="currentColor" fill="none" viewBox="0 0 48 48"><path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>
                        <p class="mt-4 text-lg font-medium">Upload an image to begin.</p>
                        <p class="text-sm mt-2">Diagrams, charts, and labeled images work best.</p>
                    </div>
                </div>
            </div>
        </div>

    </main>

    <!-- === JAVASCRIPT === --><script>
        // --- Global State Variables ---
        let SQL; // Loaded by sql.js for Anki packaging
        let tesseractWorker = null; // Tesseract.js worker for OCR
        let ocrInitialized = false; // Flag to ensure Tesseract is ready

        // --- DOM Element References (Cached for Performance) ---
        const D = {
            pages: document.querySelectorAll('.page'),
            navLinks: document.querySelectorAll('.nav-link'),
            settingsModal: document.getElementById('settings-modal'),
            saveSettingsButton: document.getElementById('save-settings'),
            settingsButton: document.getElementById('settings-button'),
            loadingModal: document.getElementById('loading-modal'),
            loadingStatus: document.getElementById('loading-status'),
            logOutput: document.getElementById('log-output'),

            // Create Flashcards Page Elements
            topicInput: document.getElementById('topic'),
            topicDeckNameInput: document.getElementById('topic-deck-name'),
            topicNumCardsInput: document.getElementById('topic-num-cards'),
            generateTopicButton: document.getElementById('generate-topic'),

            textInput: document.getElementById('text-input'),
            textDeckNameInput: document.getElementById('text-deck-name'),
            textNumCardsInput: document.getElementById('text-num-cards'),
            generateTextButton: document.getElementById('generate-text'),

            fileUploadInput: document.getElementById('file-upload'),
            fileUploadLabel: document.getElementById('file-upload-label'),
            fileNameDisplay: document.getElementById('file-name-display'),
            fileDeckNameInput: document.getElementById('file-deck-name'),
            fileNumCardsInput: document.getElementById('file-num-cards'),
            generateFileButton: document.getElementById('generate-file'),

            // Image Occlusion Page Elements (io prefix for clarity)
            ioImageUploadInput: document.getElementById('io-image-upload'),
            ioFileUploadLabel: document.getElementById('io-file-upload-label'),
            ioFileNameDisplay: document.getElementById('io-file-name-display'),
            ioScanButton: document.getElementById('io-scan-button'),
            ioExportButton: document.getElementById('io-export-button'),
            ioImageWrapper: document.getElementById('io-image-wrapper'),
            ioDisplayImage: document.getElementById('io-display-image'),
            ioCanvas: document.getElementById('io-canvas'),
            ioUploadPlaceholder: document.getElementById('io-upload-placeholder'),
            ioOcclusionList: document.getElementById('io-occlusion-list'),
            ioPlaceholder: document.getElementById('io-placeholder'),
            ioManualToggle: document.getElementById('io-manual-toggle'),
            ioDeckNameInput: document.getElementById('io-deck-name'),
        };

        // Canvas context for drawing occlusions
        let io_ctx = D.ioCanvas.getContext('2d');

        // Image Occlusion Specific State
        let io_imageBlob = null;
        let io_imageFilename = 'image.png'; // Default, updated on upload
        let io_ocrResults = []; // Stores detected text blocks (bbox, text)
        let io_selectedOcclusions = []; // Stores currently selected occlusions for Anki cards
        let io_isManualMode = false; // True if manual drawing is active
        let io_isDrawing = false; // True if a manual drawing action is in progress
        let io_manualDrawRect = {}; // Stores coordinates for current manual drawing rectangle


        // --- Utility Functions ---

        // Controls which main content page is visible
        function showPage(pageId) {
            D.pages.forEach(p => p.classList.remove('active'));
            document.getElementById(pageId).classList.add('active');
            D.navLinks.forEach(b => {
                b.classList.toggle('active', b.dataset.page === pageId);
            });
            // Specific logic for Image Occlusion to ensure Tesseract loads
            if (pageId === 'page-image-occlusion' && !ocrInitialized) {
                initTesseractWorker(); 
            }
        }
        
        // Logs messages to the console and the in-app log textarea
        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            const fullMessage = `[${timestamp}] ${message}`;
            console.log(fullMessage);
            D.logOutput.value += `\n${fullMessage}`;
            D.logOutput.scrollTop = D.logOutput.scrollHeight; // Auto-scroll
        }

        // Shows the global loading modal with a specific status message
        function showLoading(status) {
            D.loadingStatus.innerText = status;
            D.settingsModal.classList.add('hidden'); // Ensure settings modal is hidden
            D.loadingModal.classList.remove('hidden');
        }

        // Hides the global loading modal
        function hideLoading() { 
            D.loadingModal.classList.add('hidden'); 
        }

        // --- Event Listeners and Initializers ---

        // Setup navigation button click handlers
        D.navLinks.forEach(link => {
            link.addEventListener('click', () => showPage(link.dataset.page));
        });
        
        // Settings Modal: Save API Key
        D.saveSettingsButton.addEventListener('click', () => {
            const apiKey = D.apiKeyInput.value.trim();
            if (!apiKey) {
                alert("Please paste your Google AI (Gemini) API key to proceed.");
                return;
            }
            localStorage.setItem('geminiApiKey', apiKey);
            D.settingsModal.classList.add('hidden');
            log("Google AI API Key saved securely to local storage.");
        });

        // Settings Modal: Open when settings icon is clicked
        D.settingsButton.addEventListener('click', () => {
            D.apiKeyInput.value = localStorage.getItem('geminiApiKey') || ''; // Pre-fill if exists
            D.settingsModal.classList.remove('hidden');
        });
        
        // Check for API key on app load; show settings if missing
        function checkAndPromptApiKey() {
            const apiKey = localStorage.getItem('geminiApiKey');
            if (!apiKey) {
                D.settingsModal.classList.remove('hidden'); // Show modal to prompt for key
            } else {
                log("Google AI API Key found and loaded.");
            }
        }

        // Initialize sql.js library for Anki .apkg generation
        async function initSqlJs() {
            try {
                // Ensure locateFile points to the correct sql-wasm.wasm path
                SQL = await initSqlJs({ 
                    locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/${file}` 
                });
                log("Anki packager (sql.js) loaded successfully.");
            } catch (err) {
                console.error("Failed to load sql.js:", err);
                log("ERROR: Anki packager (sql.js) failed to load. Deck generation will not work. Please refresh.");
                alert("Anki packager failed to load. Please check your internet and refresh the page.");
            }
        }
        
        // App entry point - executes when DOM is fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            initSqlJs(); // Start SQL.js loading
            checkAndPromptApiKey(); // Check API key status
            // Tesseract worker is now loaded on demand when Image Occlusion tab is first accessed
        });
        
        // --- Core Functionality: Google AI (Gemini) Call ---
        async function callGemini(prompt) {
            const apiKey = localStorage.getItem('geminiApiKey');
            if (!apiKey) {
                alert("Google AI API Key not set. Please open settings and paste your key.");
                D.settingsModal.classList.remove('hidden'); // Show settings modal
                return null;
            }
            
            log(`Calling Google AI (gemini-2.5-flash-preview-09-2025)...`);
            
            // Define expected JSON schema for robust parsing and type safety
            const schema = {
                type: "OBJECT", properties: {
                    "cards": { type: "ARRAY", items: {
                        type: "OBJECT", properties: {
                            "front": { type: "STRING" }, "back": { type: "STRING" }
                        }, required: ["front", "back"]
                    }}
                }, required: ["cards"]
            };

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                generationConfig: { responseMimeType: "application/json", responseSchema: schema }
            };
            
            try {
                let response;
                let delay = 1000; // Start with 1 second delay for retries
                for (let i = 0; i < 5; i++) { // Retry up to 5 times for transient errors
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.ok) {
                        break; // Request successful, exit retry loop
                    }
                    
                    if (response.status === 429) { // Rate limit error
                        log(`Google AI rate limited. Retrying in ${delay / 1000}s...`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2; // Exponential backoff
                    } else {
                        // Other API errors (e.g., 400, 403, 500) are not retried
                        const errorBody = await response.json();
                        throw new Error(`Google AI API Error ${response.status}: ${errorBody.error.message}`);
                    }
                }

                if (!response.ok) {
                    throw new Error("Google AI call failed after multiple retries. Please check your API key and input.");
                }

                const result = await response.json();
                
                // Validate AI response structure more thoroughly
                if (!result.candidates || !result.candidates[0] || !result.candidates[0].content || !result.candidates[0].content.parts || !result.candidates[0].content.parts[0]) {
                    throw new Error("Google AI returned an unexpected or incomplete response structure.");
                }
                
                const jsonText = result.candidates[0].content.parts[0].text;
                const parsedJson = JSON.parse(jsonText);
                
                if (!parsedJson.cards || !Array.isArray(parsedJson.cards) || parsedJson.cards.length === 0) {
                    throw new Error("Google AI returned an empty or invalid card list. Please refine your prompt or input.");
                }
                
                log(`Successfully received ${parsedJson.cards.length} cards from Google AI.`);
                return parsedJson.cards;

            } catch (err) {
                console.error("Error calling Google AI:", err);
                log(`ERROR: Google AI call failed: ${err.message}`);
                alert(`Error generating cards: ${err.message}. Please check the log for details.`);
                return null;
            }
        }
        
        // --- Core Functionality: Anki .apkg Packaging and Download ---
        async function packageAndDownload(deckName, cards, mediaFiles = []) {
            if (typeof genanki === 'undefined') {
                log("ERROR: Anki packaging library (genanki.js) not found. Cannot create .apkg file. Please refresh.");
                alert("Anki packaging library failed to load. Please refresh your page.");
                hideLoading();
                return;
            }
            if (!SQL) {
                log("ERROR: Anki packager (sql.js) not ready. Please wait a few seconds.");
                alert("Anki packager not ready. Please wait a few seconds and try again.");
                hideLoading();
                return;
            }
            if (!cards || cards.length === 0) {
                log("ERROR: No cards to package. Generation might have failed or returned empty.");
                alert("No cards were generated or selected. Please try again.");
                hideLoading();
                return;
            }
            
            log(`Packaging ${cards.length} cards into .apkg file for deck "${deckName}"...`);
            showLoading("Packaging deck...");
            
            try {
                // Use Anki's Basic Model for standard Q&A cards
                const basicModel = genanki.Model.BASIC_MODEL;
                // Generate a random 10-digit deck ID to avoid conflicts
                const deckId = Math.floor(Math.random() * 9000000000) + 1000000000; 
                const deck = new genanki.Deck(deckId, deckName);

                for (const card of cards) {
                    // Ensure front and back are valid strings, provide fallbacks
                    const front = String(card.front || '').trim();
                    const back = String(card.back || '').trim();
                    if (!front || !back) {
                        log(`WARNING: Skipping a card due to empty front or back. Front: "${front}", Back: "${back}"`);
                        continue; // Skip invalid cards
                    }
                    const note = new genanki.Note(basicModel, [front, back]);
                    deck.addNote(note);
                }
                
                if (deck.notes.length === 0) {
                    throw new Error("No valid cards were created. Please check your input and try again.");
                }

                const pkg = new genanki.Package(deck, mediaFiles);
                const zip = await pkg.save(); // Returns a Uint8Array
                const blob = new Blob([zip], { type: 'application/apkg' });
                
                // Sanitize filename to prevent issues with OS/browsers
                const sanitizedDeckName = deckName.replace(/[^a-zA-Z0-9_\-\s]/g, '_').replace(/\s/g, '_');
                saveAs(blob, `${sanitizedDeckName}.apkg`);
                
                log(`SUCCESS: Deck "${deckName}" has been downloaded! Check your downloads folder.`);

            } catch (err) {
                console.error("Error generating .apkg:", err);
                log(`ERROR: Could not generate .apkg file. Details: ${err.message}.`);
                alert(`Error generating Anki deck: ${err.message}. Please check the log.`);
            } finally {
                hideLoading();
            }
        }
        
        // --- Flashcard Generator 1: From Topic ---
        D.generateTopicButton.addEventListener('click', async () => {
            D.logOutput.value = "Starting new task...";
            const topic = D.topicInput.value.trim();
            const deckName = D.topicDeckNameInput.value.trim() || `AnkiGenius: ${topic || 'Topic Cards'}`;
            const numCards = parseInt(D.topicNumCardsInput.value, 10);
            
            if (!topic) { alert("Please enter a topic to generate cards from."); return; }
            if (numCards < 1 || isNaN(numCards)) { alert("Please enter a valid number of cards (1 or more)."); return; }
            
            showLoading(`Generating ${numCards} cards on "${topic}"...`);
            const prompt = `Generate exactly ${numCards} concise, high-quality flashcards (question and answer pairs) about the topic: "${topic}". Focus on key facts, definitions, and concepts. Format as a JSON array of objects, where each object has a 'front' and 'back' key. Example: [{"front": "Question 1", "back": "Answer 1"}, {"front": "Question 2", "back": "Answer 2"}].`;
            const cards = await callGemini(prompt);
            
            if (cards) {
                await packageAndDownload(deckName, cards);
            } else {
                hideLoading();
            }
        });
        
        // --- Flashcard Generator 2: From Text ---
        D.generateTextButton.addEventListener('click', async () => {
            D.logOutput.value = "Starting new task...";
            const text = D.textInput.value.trim();
            const deckName = D.textDeckNameInput.value.trim() || 'AnkiGenius: Text Notes';
            const numCards = parseInt(D.textNumCardsInput.value, 10);

            if (!text) { alert("Please paste some text into the input area."); return; }
            if (numCards < 1 || isNaN(numCards)) { alert("Please enter a valid number of cards (1 or more)."); return; }
            
            showLoading("Analyzing text and generating cards...");
            const prompt = `Generate exactly ${numCards} concise, high-quality flashcards (question and answer pairs) based on the following text. Extract the most important facts, definitions, and concepts. Text: "${text}". Format as a JSON array of objects, where each object has a 'front' and 'back' key. Example: [{"front": "Question 1", "back": "Answer 1"}, {"front": "Question 2", "back": "Answer 2"}].`;
            const cards = await callGemini(prompt);
            
            if (cards) {
                await packageAndDownload(deckName, cards);
            } else {
                hideLoading();
            }
        });
        
        // --- Flashcard Generator 3: From File (PDF/DOCX) ---
        D.fileUploadInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                D.fileNameDisplay.textContent = file.name;
            } else {
                D.fileNameDisplay.textContent = 'No file selected.';
            }
        });

        D.generateFileButton.addEventListener('click', async () => {
            D.logOutput.value = "Starting new task...";
            const file = D.fileUploadInput.files[0];
            const deckName = D.fileDeckNameInput.value.trim() || 'AnkiGenius: Document Cards';
            const numCards = parseInt(D.fileNumCardsInput.value, 10);
            
            if (!file) { alert("Please select a .pdf or .docx file."); return; }
            if (numCards < 1 || isNaN(numCards)) { alert("Please enter a valid number of cards (1 or more)."); return; }
            
            showLoading(`Parsing file: ${file.name}...`);
            let parsedText = '';
            
            try {
                if (file.type === "application/pdf") {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        const loadingTask = pdfjsLib.getDocument({data: e.target.result});
                        const pdf = await loadingTask.promise;
                        let fullText = '';
                        for (let i = 1; i <= pdf.numPages; i++) {
                            const page = await pdf.getPage(i);
                            const textContent = await page.getTextContent();
                            fullText += textContent.items.map(item => item.str).join(' ') + '\n';
                        }
                        parsedText = fullText;
                        log(`Successfully parsed ${pdf.numPages} pages from PDF.`);
                        await generateCardsFromParsedText(parsedText, deckName, numCards);
                    };
                    reader.readAsArrayBuffer(file);
                } else if (file.name.endsWith(".docx")) {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        const result = await mammoth.extractRawText({arrayBuffer: e.target.result});
                        parsedText = result.value;
                        log("Successfully parsed DOCX file.");
                        await generateCardsFromParsedText(parsedText, deckName, numCards);
                    };
                    reader.readAsArrayBuffer(file);
                } else {
                    throw new Error("Unsupported file type. Please upload a .pdf or .docx file.");
                }
            } catch (err) {
                log(`ERROR: File parsing failed: ${err.message}`);
                alert(`File parsing failed: ${err.message}`);
                hideLoading();
            }
        });
        
        async function generateCardsFromParsedText(text, deckName, numCards) {
            if (!text || text.trim().length === 0) {
                log("ERROR: File appears to be empty or could not be read properly.");
                alert("The selected file appears to be empty or could not be read. Please try another file.");
                hideLoading();
                return;
            }
            
            showLoading("Analyzing document text and generating cards...");
            const prompt = `Generate exactly ${numCards} concise, high-quality flashcards (question and answer pairs) based on the following text. Extract the most important facts, definitions, and concepts. Text: "${text}". Format as a JSON array of objects, where each object has a 'front' and 'back' key. Example: [{"front": "Question 1", "back": "Answer 1"}, {"front": "Question 2", "back": "Answer 2"}].`;
            const cards = await callGemini(prompt);
            
            if (cards) {
                await packageAndDownload(deckName, cards);
            } else {
                hideLoading();
            }
        }
        
        // --- Image Occlusion Specific Functions ---

        // Initializes Tesseract.js worker
        async function initTesseractWorker() {
            if (ocrInitialized) return; // Already initialized

            log("Loading AI model for Image Occlusion (Tesseract.js)... This might take a moment (first time only).");
            showLoading("Loading Image Occlusion AI...");
            try {
                tesseractWorker = await Tesseract.createWorker('eng', 1, {
                    logger: m => {
                        // Log Tesseract progress for user feedback
                        if (m.status === 'recognizing text' || m.status === 'loading eng.traineddata') {
                            showLoading(`Scanning image... ${Math.round(m.progress * 100)}%`);
                        } else if (m.status.startsWith('loading')) {
                            showLoading(`Loading AI files... (${m.status})`);
                        }
                    }
                });
                ocrInitialized = true;
                log("Image Occlusion AI (Tesseract.js) loaded and ready.");
                if (D.ioImageUploadInput.files[0]) { // If an image is already uploaded, enable scan button
                    D.ioScanButton.disabled = false;
                }
            } catch (err) {
                console.error("Error loading Tesseract.js:", err);
                log(`ERROR: Image Occlusion AI failed to load: ${err.message}. Please check your internet connection.`);
                alert("Image Occlusion AI failed to load. Please check your internet connection and refresh.");
            } finally {
                hideLoading();
            }
        }

        // Handles image file selection for Image Occlusion
        D.ioImageUploadInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) {
                D.ioFileNameDisplay.textContent = 'No image selected.';
                D.ioUploadPlaceholder.classList.remove('hidden');
                D.ioImageWrapper.classList.add('hidden');
                D.ioScanButton.disabled = true;
                D.ioExportButton.disabled = true;
                io_ocrResults = [];
                io_selectedOcclusions = [];
                io_updateOcclusionList();
                io_ctx.clearRect(0, 0, D.ioCanvas.width, D.ioCanvas.height);
                return;
            }

            D.ioFileNameDisplay.textContent = file.name;
            io_imageBlob = file;
            io_imageFilename = file.name.replace(/[^a-zA-Z0-9.]/g, '_'); // Sanitize filename

            const reader = new FileReader();
            reader.onload = (event) => {
                D.ioDisplayImage.src = event.target.result;
                D.ioDisplayImage.onload = () => {
                    // Adjust canvas size to match the displayed image's current dimensions
                    D.ioCanvas.width = D.ioDisplayImage.clientWidth;
                    D.ioCanvas.height = D.ioDisplayImage.clientHeight;
                    
                    D.ioImageWrapper.classList.remove('hidden');
                    D.ioUploadPlaceholder.classList.add('hidden');
                    D.ioScanButton.disabled = !ocrInitialized; // Enable if Tesseract is ready
                    D.ioExportButton.disabled = true;
                    io_ocrResults = [];
                    io_selectedOcclusions = [];
                    io_updateOcclusionList();
                    io_ctx.clearRect(0, 0, D.ioCanvas.width, D.ioCanvas.height); // Clear canvas on new image
                    io_drawBoxes(); // Draw any existing selected boxes, or nothing if list is empty
                };
            };
            reader.readAsDataURL(file);
        });

        // Event listener for Image Occlusion Scan button
        D.ioScanButton.addEventListener('click', async () => {
            if (!tesseractWorker || !ocrInitialized) {
                alert("Image Occlusion AI is not ready. Please wait a moment for it to load, or refresh the page.");
                return;
            }
            if (!D.ioDisplayImage.src) {
                alert("Please upload an image first to scan.");
                return;
            }
            
            showLoading("Scanning image for text blocks..."); 
            try {
                const { data } = await tesseractWorker.recognize(D.ioDisplayImage.src, {}, {
                    tessedit_pageseg_mode: 3, // PSM_AUTO: Automatic page segmentation mode (best for varied layouts)
                });

                // Combine lines and words, filter out empty/whitespace-only items
                io_ocrResults = data.lines.concat(data.words).filter(item => item.text && item.text.trim().length > 1);

                if (io_ocrResults.length === 0) {
                    log("Scan complete. No significant text found by AI. Consider using Manual Mode for diagrams.");
                } else {
                    log(`Scan complete. Found ${io_ocrResults.length} potential text blocks.`);
                }
                io_drawBoxes(); // Redraw canvas to show new detected boxes
            } catch (err) {
                console.error("Image scanning failed:", err);
                log(`ERROR: Image scanning failed: ${err.message}.`);
                alert("Image scanning failed. Please try a different image or use Manual Mode.");
            } finally {
                hideLoading();
            }
        });

        // Toggle Manual Mode for drawing
        D.ioManualToggle.addEventListener('change', (e) => {
            io_isManualMode = e.target.checked;
            D.ioCanvas.style.cursor = io_isManualMode ? 'crosshair' : 'default';
            if (!io_isManualMode) {
                io_isDrawing = false; // Stop any ongoing drawing
                io_drawBoxes(); // Redraw to clear any temporary manual drawing outlines
            }
        });

        // Helper: Convert client coordinates (mouse position on canvas) to natural image coordinates
        function getNaturalCoords(clientX, clientY) {
            const rect = D.ioCanvas.getBoundingClientRect();
            const scaleX = D.ioDisplayImage.naturalWidth / D.ioCanvas.width;
            const scaleY = D.ioDisplayImage.naturalHeight / D.ioCanvas.height;
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        // Helper: Convert natural image bounding box to canvas display coordinates
        function scaleBboxToCanvas(bbox) {
            const scaleX = D.ioCanvas.width / D.ioDisplayImage.naturalWidth;
            const scaleY = D.ioCanvas.height / D.ioDisplayImage.naturalHeight;
            return { 
                x: bbox.x0 * scaleX, 
                y: bbox.y0 * scaleY, 
                w: (bbox.x1 - bbox.x0) * scaleX, 
                h: (bbox.y1 - bbox.y0) * scaleY 
            };
        }

        // Draws all detected text boxes (green outline) and selected occlusions (blue fill) on the canvas
        function io_drawBoxes() {
            io_ctx.clearRect(0, 0, D.ioCanvas.width, D.ioCanvas.height); // Clear entire canvas

            // Draw all detected text boxes with green outline (if not in manual mode)
            if (!io_isManualMode) {
                for (const item of io_ocrResults) {
                    const { x, y, w, h } = scaleBboxToCanvas(item.bbox);
                    io_ctx.strokeStyle = 'rgba(0, 200, 0, 0.6)'; // Green outline
                    io_ctx.lineWidth = 2;
                    io_ctx.strokeRect(x, y, w, h);
                }
            }
            
            // Draw selected occlusion boxes with blue fill
            for (const occ of io_selectedOcclusions) {
                if (occ.bbox) {
                    const { x, y, w, h } = scaleBboxToCanvas(occ.bbox);
                    io_ctx.fillStyle = 'rgba(30, 64, 175, 0.7)'; // Dark blue fill
                    io_ctx.fillRect(x, y, w, h);
                }
            }
        }
        
        // Adds an occlusion to the selected list and updates UI
        function io_addOcclusion(text, bbox) {
            // Check for exact duplicate to avoid adding same occlusion multiple times
            if (io_selectedOcclusions.some(o => o.text === text && 
                                             o.bbox && 
                                             o.bbox.x0 === bbox.x0 && o.bbox.y0 === bbox.y0 && 
                                             o.bbox.x1 === bbox.x1 && o.bbox.y1 === bbox.y1)) {
                return; 
            }
            io_selectedOcclusions.push({ text, bbox });
            io_updateOcclusionList();
        }

        // Removes an occlusion from the selected list and updates UI
        function io_removeOcclusion(textToRemove) {
            io_selectedOcclusions = io_selectedOcclusions.filter(occ => occ.text !== textToRemove);
            io_updateOcclusionList();
            io_drawBoxes(); // Redraw canvas to remove the visual occlusion
        }

        // Updates the HTML list displaying selected occlusions
        function io_updateOcclusionList() {
            if (io_selectedOcclusions.length === 0) {
                D.ioOcclusionList.innerHTML = '';
                D.ioOcclusionList.appendChild(D.ioPlaceholder);
                D.ioExportButton.disabled = true;
            } else {
                D.ioPlaceholder.remove(); // Remove placeholder
                D.ioOcclusionList.innerHTML = ''; // Clear existing items
                io_selectedOcclusions.forEach(occ => {
                    const item = document.createElement('div');
                    item.className = 'occlusion-item';
                    item.textContent = occ.text;

                    const btn = document.createElement('button');
                    btn.innerHTML = '&times;'; // 'x' icon
                    btn.className = 'occlusion-remove-btn';
                    btn.onclick = () => io_removeOcclusion(occ.text); // Bind remove handler
                    
                    item.appendChild(btn);
                    D.ioOcclusionList.appendChild(item);
                });
                D.ioExportButton.disabled = false; // Enable export button
            }
        }

        // --- Canvas Event Handlers (for drawing and selecting) ---

        // Mouse down event for manual drawing
        D.ioCanvas.addEventListener('mousedown', (e) => {
            if (io_isManualMode) {
                io_isDrawing = true;
                const rect = D.ioCanvas.getBoundingClientRect();
                io_manualDrawRect = { 
                    startX: e.clientX - rect.left, 
                    startY: e.clientY - rect.top,
                    currentX: e.clientX - rect.left,
                    currentY: e.clientY - rect.top
                };
            }
        });

        // Mouse move event for drawing feedback
        D.ioCanvas.addEventListener('mousemove', (e) => {
            if (io_isManualMode && io_isDrawing) {
                io_drawBoxes(); // Redraw existing occlusions and outlines
                
                const rect = D.ioCanvas.getBoundingClientRect();
                io_manualDrawRect.currentX = e.clientX - rect.left;
                io_manualDrawRect.currentY = e.clientY - rect.top;

                const { startX, startY, currentX, currentY } = io_manualDrawRect;
                const x = Math.min(startX, currentX);
                const y = Math.min(startY, currentY);
                const w = Math.abs(currentX - startX);
                const h = Math.abs(currentY - startY);
                
                io_ctx.strokeStyle = '#6366f1'; // Indigo for current drawing rectangle
                io_ctx.lineWidth = 2;
                io_ctx.strokeRect(x, y, w, h);
            }
        });

        // Mouse up event for finalizing manual drawing
        D.ioCanvas.addEventListener('mouseup', (e) => {
            if (io_isManualMode && io_isDrawing) {
                io_isDrawing = false;
                
                const { startX, startY, currentX, currentY } = io_manualDrawRect;
                const bboxDisplay = { 
                    x0: Math.min(startX, currentX), 
                    y0: Math.min(startY, currentY), 
                    x1: Math.max(startX, currentX), 
                    y1: Math.max(startY, currentY) 
                };

                // Convert display coordinates to natural image coordinates for storage
                const scaleX_inv = D.ioDisplayImage.naturalWidth / D.ioCanvas.width;
                const scaleY_inv = D.ioDisplayImage.naturalHeight / D.ioCanvas.height;

                const naturalBbox = {
                    x0: bboxDisplay.x0 * scaleX_inv, 
                    y0: bboxDisplay.y0 * scaleY_inv,
                    x1: bboxDisplay.x1 * scaleX_inv, 
                    y1: bboxDisplay.y1 * scaleY_inv
                };

                const text = prompt("Enter the text or concept for this occlusion:");
                if (text && text.trim() !== '') {
                    io_addOcclusion(text.trim(), naturalBbox);
                }
                io_drawBoxes(); // Redraw to show the new occlusion filled
            }
        });

        // Click event for selecting/deselecting OCR-detected boxes (Auto Mode)
        D.ioCanvas.addEventListener('click', (e) => {
            if (io_isManualMode || io_isDrawing) return; // Only operate in auto mode

            const { x, y } = getNaturalCoords(e.clientX, e.clientY); // Click coordinates in natural image scale
            
            let clickedItem = null;
            let smallestArea = Infinity;

            // Find the smallest detected text box that was clicked
            for (const item of io_ocrResults) {
                const { bbox } = item;
                if (x >= bbox.x0 && x <= bbox.x1 && y >= bbox.y0 && y <= bbox.y1) {
                    const area = (bbox.x1 - bbox.x0) * (bbox.y1 - bbox.y0);
                    if (area < smallestArea) {
                        smallestArea = area;
                        clickedItem = item;
                    }
                }
            }

            if (clickedItem) {
                const { bbox, text } = clickedItem;
                // Check if this specific box is already selected based on its bounding box
                const existingIndex = io_selectedOcclusions.findIndex(o => 
                    o.bbox && 
                    o.bbox.x0 === bbox.x0 && o.bbox.y0 === bbox.y0 && 
                    o.bbox.x1 === bbox.x1 && o.bbox.y1 === bbox.y1
                );
                
                if (existingIndex > -1) {
                    // Already selected, so deselect it
                    io_selectedOcclusions.splice(existingIndex, 1);
                } else {
                    // Not selected, so add it
                    io_addOcclusion(text.trim(), bbox);
                }
                io_drawBoxes(); // Redraw canvas to update visual highlights
            }
        });

        // --- Image Occlusion: Export to Anki .apkg ---
        D.ioExportButton.addEventListener('click', async () => {
            if (io_selectedOcclusions.length === 0) {
                alert("Please select at least one area to occlude before generating the deck.");
                return;
            }
            if (!SQL) {
                alert("Anki packager is not ready. Please wait a moment and try again.");
                return;
            }
            if (!io_imageBlob) {
                 alert("No image is currently uploaded for occlusion. Please upload an image first.");
                 return;
            }

            showLoading("Generating Image Occlusion Deck...");
            try {
                // Use Anki's Cloze Model for image occlusion cards
                const clozeModel = genanki.Model.CLOZE_MODEL;
                const deckName = D.ioDeckNameInput.value.trim() || 'AnkiGenius: Image Occlusion Deck';
                const deck = new genanki.Deck(Math.floor(Math.random() * 9000000000) + 1000000000, deckName);
                
                // The image itself is a media file
                const mediaFiles = [{ name: io_imageFilename, data: io_imageBlob }];
                
                let clozeTextContent = '';
                // Generate cloze deletions from the selected occlusions
                io_selectedOcclusions.forEach((occ, i) => {
                    // Important: Sanitize text that might contain Anki cloze syntax (e.g., {{...}})
                    const cleanText = occ.text.replace(/{{/g, '&#123;&#123;').replace(/}}/g, '&#125;&#125;');
                    clozeTextContent += `{{c${i+1}::${cleanText}}}`;
                });

                // The Anki note front will contain the cloze deletions and the image
                // The back can be optionally left blank or contain a hint.
                const noteText = `${clozeTextContent}<br><br><img src="${io_imageFilename}">`;
                // Add a dummy back field, as Cloze cards don't strictly need it to display, 
                // but the model expects it.
                const note = new genanki.Note(clozeModel, [noteText, ""]); 
                deck.addNote(note);
                
                const pkg = new genanki.Package(deck, mediaFiles);
                const zip = await pkg.save();
                
                const sanitizedDeckName = deckName.replace(/[^a-zA-Z0-9_\-\s]/g, '_').replace(/\s/g, '_');
                saveAs(new Blob([zip], { type: 'application/apkg' }), `${sanitizedDeckName}.apkg`);
                log(`SUCCESS: Image Occlusion Deck "${deckName}" downloaded!`);

            } catch (err) {
                console.error("Error generating image occlusion .apkg:", err);
                log(`ERROR: Could not generate image occlusion deck. Details: ${err.message}`);
                alert(`Failed to generate image occlusion deck: ${err.message}. Please check console for more info.`);
            }
            finally { hideLoading(); }
        });
        
    </script>
</body>
</html>

